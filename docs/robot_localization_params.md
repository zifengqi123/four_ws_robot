# robot_localization_params

[официальная документация](http://wiki.ros.org/robot_localization)

## Стандартные параметры

`frequency` - частота в Гц, при которой фильтр выдает оценку состояния

`sensor_timeout` - реальный период в секундах, по истечении которого мы считаем, что время ожидания любого датчика истекло. В этом случае мы выполняем цикл прогнозирования для EKF без его коррекции. Этот параметр можно рассматривать как величину, обратную минимальной частоте, при которой фильтр будет генерировать новый выходной сигнал

`two_d_mode` - если робот работает в плоской среде и вам удобно игнорировать незначительные колебания грунта (как сообщает IMU), то установите для этого значение true. Он объединит значения 0 для всех трехмерных переменных (Z, крен, тангаж и их соответствующие скорости и ускорения). Это предотвращает "взрыв" ковариаций для этих значений, гарантируя при этом, что оценка состояния вашего робота остается привязанной к плоскости X-Y

`map_frame` - название фрейма карты (обычно `map`)

`odom_frame` - название фрейма одометрии (обычно `odom`)

`base_link_frame` - название фрейма основной точки робота  (обычно `base_link` или `base_footprint`)

`base_link_frame_output` - eсли вы используете несколько экземпляров EKF и хотите "переопределить" выходное преобразование и сообщение, чтобы этот кадр был для его `child_frame_id`, вы можете установить это. Является `base_link_frame_output` необязательным и по умолчанию будет иметь значение `base_link_frame`. Это помогает включить отключенные деревья TF при запуске нескольких экземпляров EKF. Когда окончательное состояние вычислено, мы «переопределяем» выходное преобразование и сообщение, чтобы иметь этот кадр для своего файла `child_frame_id`

`world_frame` - если вы объединяете только непрерывные данные о местоположении, такие как одометрия колесного энкодера, визуальная одометрия или данные IMU, установите `world_frame` свое `odom_frame` значение. Если вы объединяете глобальные абсолютные данные о местоположении, которые подвержены дискретным скачкам (например, GPS или обновления положения по наблюдениям ориентиров), то установите `world_frame` свое `map_frame` значение; убедитесь, что что-то еще генерирует преобразование `odom` -> `base_link`. Это может быть даже другой экземпляр узла `robot_localization` оценки состояния. Однако этот экземпляр не должен объединять глобальные данные

Значения по умолчанию для `map_frame`, `odom_frame` и `base_link_frame` — `map` , `odom` и `base_link` соответственно. Параметр `base_link_frame_output` по умолчанию имеет значение `base_link_frame`. Параметр `world_frame` по умолчанию имеет значение `odom_frame`

`transform_time_offset` - некоторые пакеты требуют, чтобы ваши преобразования были датированы будущим с небольшим смещением по времени. Значение этого параметра будет добавлено к отметке времени преобразования `map` -> `odom` или `odom` -> `base_link` , генерируемого узлами оценки состояния в `robot_localization`

`transform_timeout` - пакет `robot_localization` использует метод `lookupTransform` от `tf2` для запроса преобразований. Этот параметр указывает, как долго мы хотели бы подождать, если преобразование еще недоступно. Значение по умолчанию равно 0, если оно не задано. Значение 0 означает, что мы просто получаем последнее доступное преобразование (см. реализацию `tf2`), поэтому мы не блокируем фильтр. Указание ненулевого значения `transform_timeout` влияет на синхронизацию фильтра, поскольку он ожидает максимального значения `transform_timeout` для того, чтобы преобразование стало доступным. Это напрямую подразумевает, что в большинстве случаев указанная желаемая скорость вывода не достигается, поскольку фильтру приходится ждать преобразований при обновлении

`[sensor]` - для каждого датчика пользователям необходимо определить этот параметр в зависимости от типа сообщения. Например, если мы определим один источник сообщений Imu и два источника сообщений Odometry, конфигурация будет выглядеть следующим образом

```xml
<param name="imu0" value="robot/imu/data"/>
<param name="odom0" value="wheel_encoder/odometry"/>
<param name="odom1" value="visual_odometry/odometry"/>
```

Индекс для каждого имени параметра основан на 0 (например, `odom0`, `odom1` и т.д.) и должен определяться последовательно (например, не используйте `pose0` и `pose2`, если вы не определили `pose1`). Значения для каждого параметра являются названием топика для этого датчика

`[sensor]_config` - для каждого из сообщений датчика, определенных выше, пользователи должны указать, какие переменные из этих сообщений должны быть объединены в окончательную оценку состояния. Пример конфигурации одометрии может выглядеть следующим образом:

```xml
<rosparam param="odom0_config">[true,  true,  false,
                                false, false, true,
                                true,  false, false,
                                false, false, true,
                                false, false, false]</rosparam>
```

Порядок логических значений следующий: X, Y, Z, roll, pitch, yaw, X', Y', Z', roll', pitch', yaw', X'', Y'', Z''

`[sensor]_queue_size` - пользователи могут использовать эти параметры для настройки размеров очереди обратного вызова для каждого датчика. Это полезно, если значение вашего частотного параметра намного ниже частоты вашего датчика, поскольку это позволяет фильтру учитывать все измерения, полученные в промежутках между циклами обновления

`[sensor]_differential` - Для каждого из описанных выше сообщений датчика, содержащих информацию о позе, пользователи могут указать, следует ли дифференцировать переменные позы. Если заданному значению присвоено значение true, то для измерения в момент времени t
от рассматриваемого датчика мы сначала вычитаем измерение в момент времени t−1
, и преобразуйте полученное значение в скорость. Эта настройка особенно полезна, если у вашего робота есть два источника информации об абсолютной позе, например, измерения рыскания с помощью одометра и IMU. В этом случае, если отклонения на входных источниках настроены неправильно, эти измерения могут не синхронизироваться друг с другом и вызывать колебания в фильтре, но, интегрируя одно или оба из них по-разному, мы избегаем этого сценария.
Пользователям следует соблюдать осторожность при использовании этого параметра для данных ориентации, поскольку преобразование в скорость означает, что ковариация для переменных состояния ориентации будет расти неограниченно (если только не используется другой источник данных абсолютной ориентации). Если вы просто хотите, чтобы все ваши переменные позы начинались с 0
, то, пожалуйста, используйте параметр _relative

`[sensor]_relative` - если для этого параметра установлено значение true, то все измерения с этого датчика будут объединены относительно первого измерения, полученного с этого датчика. Это полезно, если, например, вы хотите, чтобы ваша оценка состояния всегда начиналась с (0,0,0)
 и со значениями крена, тангажа
и рыскания
, равными (0,0,0)
. Это аналогично параметру _differential, но вместо удаления измерения в момент времени t−1
мы всегда удаляем измерение в момент времени 0
, и измерение не преобразуется в скорость

`imuN_remove_gravitational_acceleration` - при объединении данных акселерометра от IMU этот параметр определяет, будет ли ускорение, вызванное силой тяжести, удалено из измерения ускорения перед его объединением

`gravitational_acceleration` - если `imuN_remove_gravitational_acceleration` установлено значение `true`, то этот параметр определяет ускорение по оси Z из-за силы тяжести, которое будет удалено из данных линейного ускорения IMU. По умолчанию 9,80665 (м/с^2)

`initial_state` - Запускает фильтр с заданным состоянием. Состояние задается в виде 15-мерного вектора в том же порядке, что и конфигурации датчиков. Например, чтобы запустить вашего робота в положении (5.0,4.0,3.0), отклонение от курса 1,57 и линейная скорость (0,1,0,2,0,3), вы бы использовали:

```xml
<rosparam param="initial_state">[5.0,  4.0,  3.0,
                                 0.0,  0.0,  1.57,
                                 0.1,  0.2,  0.3,
                                 0.0,  0.0,  0.0,
                                 0.0,  0.0,  0.0]</rosparam>
```

`publish_tf` - если значение `true`, узел оценки состояния опубликует преобразование из кадра, указанного параметром `world_frame`, в кадр, указанный параметром `base_link_frame`. По умолчанию установлено значение `true`.

`publish_acceleration` - если `true`, узел оценки состояния опубликует состояние линейного ускорения. По умолчанию `false`

`permit_corrected_publication` - когда узлы оценки состояния публикуют состояние во время t, но затем получают измерение с отметкой времени < t , они повторно публикуют исправленное состояние с той же отметкой времени, что и предыдущая публикация. Установка для этого параметра значения `false` отключает это поведение. По умолчанию `false`

`print_diagnostics` - Если `true`, узел оценки состояния будет публиковать диагностические сообщения в `/diagnostics` топике. Это полезно для отладки вашей конфигурации и данных датчиков

## Расширенные параметры

`use_control` - если значение `true`, узел оценки состояния прослушает топик `/cmd_vel` для сообщения `geometry_msgs/Twist` и использует это для генерации условия ускорения. Затем этот термин используется при прогнозировании состояния робота. Это особенно полезно в ситуациях, когда даже небольшое отставание в сходимости для заданной переменной состояния вызывает проблемы в вашем приложении (например, смещение лидара во время поворотов). По умолчанию установлено значение `false`.
Обратите внимание, что наличие и включение данных о линейном ускорении из IMU в настоящее время “перекрывает” прогнозируемое значение линейного ускорения

`stamped_control` - если значение `true` и `use_control` также равно `true`, выполняется поиск сообщения `geometry_msgs/TwistStamped` вместо сообщения `geometry_msgs/Twist`

`control_timeout` - если `use_control` имеет значение `true` и за это время, указанное в секундах, не получено ни одной управляющей команды, термин ускорения, основанный на управлении, перестает применяться

`control_config` - определяет, какие переменные в сообщении cmd_vel используются при прогнозировании состояния. Порядок значений таков: X, Y,Z, крен, тангаж, рыскание
. Используется только в том случае, если `use_control` имеет значение `true`

```xml
<rosparam param="control_config">[true,  false, false,
                                  false, false, true]</rosparam>
```

`acceleration_limits` - насколько быстро ваш робот может ускоряться в каждом измерении. Соответствует порядку параметров в `control_config`. Используется только в том случае, если `use_control` имеет значение `true`

```xml
<rosparam param="acceleration_limits">[1.3, 0.0, 0.0,
                                       0.0, 0.0, 3.2]</rosparam>
```

`deceleration_limits` - как быстро ваш робот может замедляться для каждого измерения. Соответствует порядку параметров в `control_config`. Используется только в том случае, если `use_control` имеет значение `true`

`acceleration_gains` - если ваш робот не может мгновенно достичь своего предельного ускорения, допустимым изменением можно управлять с помощью этих коэффициентов усиления. Используется только в том случае, если `use_control` имеет значение `true`

```xml
<rosparam param="acceleration_limits">[0.8, 0.0, 0.0,
                                       0.0, 0.0, 0.9]</rosparam>
```

`deceleration_gains` - если ваш робот не может мгновенно достичь своего предела замедления, допустимым изменением можно управлять с помощью этих коэффициентов усиления. Используется только в том случае, если use_control имеет значение true

`smooth_lagged_data` - если какой-либо из ваших датчиков выдает данные с временными метками, которые старше самого последнего обновления фильтра (проще говоря, если у вас есть источник данных датчика с задержкой), установка этого параметра в значение true позволит фильтру при получении данных с задержкой вернуться к последнему состоянию, предшествующему измерению с задержкой, затем обработайте все измерения до текущего времени. Это особенно полезно для измерений, которые поступают с узлов, требующих интенсивной загрузки процессора для генерации оценок положения (например, сопоставителей лазерного сканирования), поскольку они часто отстают от текущего времени

`history_length` - если для параметра `smooth_lagged_data` установлено значение `true`, этот параметр определяет количество секунд, в течение которых фильтр будет сохранять свое состояние и историю измерений. Это значение должно быть как минимум таким же большим, как разница во времени между вашими запаздывающими измерениями и текущим временем

`[sensor]_nodelay` - если значение `true`, задает подсказку TCPNoDelay transport. Есть некоторые свидетельства того, что алгоритм Нэгла мешает своевременному приему больших типов сообщений, таких как сообщение `nav_msgs/Odometry`. Установка значения true для входных данных отключает алгоритм Нэгла для этого подписчика. По умолчанию установлено значение `false`

`[sensor]_threshold` - если ваши данные подвержены отклонениям, используйте эти пороговые настройки, выраженные в виде расстояний Махаланобиса, чтобы определить, насколько далеко от текущего состояния транспортного средства разрешено находиться датчику при измерении. Для каждого из них по умолчанию используется значение `numeric_limits<double>::max()`, если оно не указано

`debug` - логический флаг, указывающий, следует ли запускать в режиме отладки. ПРЕДУПРЕЖДЕНИЕ: установка этого параметра в значение `true` приведет к генерированию огромного объема данных. Данные записываются в значение параметра `debug_out_file`. По умолчанию установлено значение `false`.

`debug_out_file` - если `debug` имеет значение `true`, то файл, в который записываются выходные данные отладки.

`process_noise_covariance` - ковариация шума процесса, обычно обозначаемая Q, используется для моделирования неопределенности на этапе прогнозирования алгоритмов фильтрации. Его может быть трудно настроить, и он был представлен в качестве параметра для упрощения настройки. Этот параметр можно оставить в покое, но, настроив его, вы добьетесь превосходных результатов. В общем, чем больше значение Q относительно дисперсии для данной переменной во входном сообщении, тем быстрее фильтр будет сходиться к значению в измерении

`dynamic_process_noise_covariance` - если значение `true`, то будет динамически масштабироваться `process_noise_covariance` в зависимости от скорости робота. Это полезно, например, когда вы хотите, чтобы ковариация ошибки оценки вашего робота перестала расти, когда робот неподвижен. По умолчанию установлено значение `false`

`initial_estimate_covariance` - ковариация оценки, обычно обозначаемая P, определяет ошибку в оценке текущего состояния. Параметр позволяет пользователям устанавливать начальное значение для матрицы, которое будет влиять на то, насколько быстро сходится фильтр. Например, если пользователи устанавливают значение в позиции [0,0] до очень малого значения, например, 1e-12, а затем попытайтесь объединить измерения положения X с высоким значением отклонения для X
, тогда фильтр будет очень медленно "доверять" этим измерениям, и время, необходимое для сходимости, увеличится. Опять же, пользователи должны быть осторожны с этим параметром. При использовании только данных о скорости (например, без информации об абсолютной позе) пользователи, скорее всего, не захотят устанавливать начальные значения ковариации для переменных абсолютной позы на большие числа. Это связано с тем, что эти ошибки будут расти неограниченно (из-за отсутствия абсолютных измерений положения для уменьшения погрешности), и начало их с больших значений не принесет пользы оценке состояния

`reset_on_time_jump` - если установлено значение `true` и `rise::Time::isSimTime()` имеет значение `true`, фильтр будет сброшен в неинициализированное состояние при обнаружении перехода назад во времени по теме. Это полезно при работе с большими данными, поскольку пакет может быть перезапущен без перезапуска узла

`predict_to_current_time` - если установлено значение `true`, фильтр прогнозирует и корректирует с точностью до времени последнего измерения (по умолчанию), но теперь также будет прогнозировать с точностью до текущего временного шага

`disabled_at_startup` - если установлено значение `true`, фильтр не будет запускаться при запуске